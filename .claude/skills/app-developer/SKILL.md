---
name: app-developer
description: >
  Full-stack app development and UX engineering skill that audits, researches,
  and auto-implements upgrades for coaching, wellness, and personal development
  apps. Built on competitive intelligence from Calm, Jay Shetty Genius, Noom,
  Headspace, Fabulous, BetterUp, and Remente. Skips past the first 10-20
  obvious enhancements to deliver research-backed, systems-level improvements.
  Runs in audit-verify-auto-accept loops until full passes. Protects against
  scope drift for multi-hat founders. Triggers on: audit my app, improve my
  app UX, app development, fix my retention, upgrade my onboarding, build a
  coaching app, app architecture, data model, feedback loops, build my app.
  Outputs: audit reports, implementation plans, code changes, UX architecture
  docs. Reads: voice-profile.md, positioning.md, audience.md, stack.md.
  Writes: ./app/audit-report.md, ./app/architecture.md, ./app/upgrades.md,
  assets.md, learnings.md.
---

# /app-developer — App Development & UX Engineering Engine

Most app developers start with the obvious. Better colors. Rounder buttons.
A nicer onboarding screen. Those are steps 1 through 10 and they do not
move the needle.

This skill starts at step 11. It assumes you have a working app (or an
idea worth building) and engineers the systems, data models, feedback
loops, and UX architecture that separate a side project from a product
people cannot stop using.

Built on competitive teardowns of Calm ($596M revenue, 4.5M paid subs),
Jay Shetty Genius (passive content trap), Noom (CBT-powered identity
change), Headspace (structured curriculum), Insight Timer (127K free
sessions, 27M community), Fabulous (habit architecture), BetterUp
(AI + human coaching handoff), and Remente (life-area scoring).

This skill protects the multi-hat founder. You are the developer, the
designer, the content creator, and the CEO. This skill keeps you from
drifting into polish when you need architecture, or features when you
need feedback loops.

Read ./brand/ per _system/brand-memory.md

Follow all output formatting rules from _system/output-format.md

---

## Brand Memory Integration

On every invocation, check for existing brand context.

### Reads (if they exist)

| File | What it provides | How it shapes output |
|------|-----------------|---------------------|
| ./brand/voice-profile.md | Brand voice, tone, vocabulary | All audit reports and UX copy recommendations match the brand voice. Justin Ray's voice is the default requirement. |
| ./brand/positioning.md | Market angle, differentiators | Shapes which competitive gaps matter most for THIS app |
| ./brand/audience.md | User profiles, pain points | Drives personalization architecture and retention strategy |
| ./brand/stack.md | Connected tools, APIs | Determines what can be built vs what needs new tooling |

### Writes

| File | What it contains |
|------|-----------------|
| ./app/audit-report.md | Full audit with scored findings and prioritized fixes |
| ./app/architecture.md | Systems architecture, data models, feedback loops |
| ./app/upgrades.md | Implemented changes log with before/after |
| ./brand/assets.md | Append new app assets to registry |
| ./brand/learnings.md | Append app development learnings |

### Context Loading Behavior

1. Check whether `./brand/` exists.
2. If it exists, read `voice-profile.md`, `positioning.md`, `audience.md`, and `stack.md` if present.
3. If loaded, show the user what you found:
   ```
   Brand context loaded:
   ├── Voice Profile    ✓ "{tone summary}"
   ├── Positioning      ✓ "{primary angle}"
   ├── Audience         ✓ "{segment summary}"
   └── Stack            ✓ "{tools detected}"

   Using this to shape all UX recommendations
   and copy decisions.
   ```
4. If files are missing, proceed without them. Note at the end:
   ```
   → /brand-voice would ensure all UX copy matches
     your voice
   → /positioning-angles would sharpen which
     competitive gaps to target
   ```
5. If no brand directory exists at all:
   ```
   No brand profile found — this skill works
   standalone but is sharper with brand context.
   → /start-here to build your brand foundation
   ```

### Voice Profile Requirement

Justin Ray's voice profile is a hard requirement for all copy
recommendations, microcopy, onboarding language, notification
text, empty states, and error messages generated by this skill.
If voice-profile.md exists, inject it into every piece of user-facing
text this skill produces. If it does not exist, flag it as a blocker
for copy-related upgrades and offer to run /brand-voice first.

---

## Iteration Detection

Before starting any mode, check whether `./app/audit-report.md` already exists.

### If audit-report.md EXISTS → Upgrade Mode

Do not re-audit from scratch. Instead:

1. Read the existing audit report and upgrades log.
2. Present a summary of current state:
   ```
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

     EXISTING APP AUDIT
     Last updated {date} by /app-developer

   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

     Audit score: {score}/100
     Upgrades completed: {n}
     Upgrades remaining: {n}
     Last focus area: {area}

     ──────────────────────────────────────────────

     What would you like to do?

     ① Continue upgrades (pick up where we left off)
     ② Re-audit (full scan with fresh research)
     ③ Focus on a specific area
     ④ Review what changed since last session
   ```

3. Process the user's choice and continue.

### If audit-report.md DOES NOT EXIST → Full Audit Mode

Proceed to mode selection below.

---

## The Core Job

Engineer app improvements that skip past the obvious and deliver
systems-level upgrades backed by competitive research.

This skill does NOT:
- Suggest better color palettes (step 1)
- Recommend font changes (step 2)
- Propose generic "improve the onboarding" without specifics (step 3)
- Add features without feedback loops (step 4)
- Build without data models (step 5)
- Ship without error states (step 6)
- Deploy without retention mechanics (step 7)
- Launch without analytics hooks (step 8)
- Release without offline resilience (step 9)
- Go live without edge case handling (step 10)

This skill DOES:
- Engineer adaptive personalization systems that learn from user behavior
- Build event-sourced data architectures that power progressive enhancement
- Design feedback loops where every feature generates data that improves
  every other feature
- Implement the invisible UX layer (loading, error, empty, edge states)
  that separates amateur from world-class
- Create retention systems based on identity transformation, not just streaks
- Architect AI integration that amplifies human coaching, not replaces it
- Build for the multi-hat founder who cannot afford scope drift

---

## Three Modes

### Mode 1: Full Audit
Use when: First time running, or major app changes need reassessment.
Process: Deep competitive research, five-layer audit, scored findings,
prioritized upgrade plan with auto-accept for the first 10 enhancements.

### Mode 2: Targeted Upgrade
Use when: Specific area needs improvement (retention, onboarding,
data model, personalization, etc.).
Process: Focused research on that area, competitive benchmarking,
implementation with auto-accept.

### Mode 3: Build from Idea
Use when: Starting from a concept, not an existing app.
Process: Architecture-first design using competitive intelligence,
data model, UX flow, feedback loop mapping, then scaffold.

How to choose:

```
  What are we working with?

  ① I have an existing app that needs upgrading
     → Full Audit mode
  ② I need to fix a specific problem
     → Targeted Upgrade mode
  ③ I am building something new
     → Build from Idea mode
```

---

## The Skip-Past-10 Protocol

This is the defining behavior of the skill. Most developers and most
AI coding assistants start with cosmetic fixes. This skill assumes
those are either done or irrelevant and jumps to systems-level work.

### What Gets Auto-Accepted (Enhancements 1-10)

When the skill identifies these categories of improvement, it
implements them WITHOUT asking for confirmation and reports what
it did after the fact. These are table-stakes fixes that no
reasonable developer would reject:

```
  AUTO-ACCEPT TIER (implement and report)

  ① Skeleton loading screens replacing spinners
     Research: 20% faster perceived load time

  ② Empty state designs with actionable CTAs
     Research: First-use empty states are onboarding
     opportunities, not dead ends

  ③ Optimistic UI for high-frequency actions
     Research: Instant-feel interactions for saves,
     toggles, favorites, check-ins

  ④ Inline form validation with conversational
     microcopy (in brand voice)
     Research: "That email doesn't look right"
     beats "Invalid input"

  ⑤ Interrupted session recovery
     Research: User backgrounds app mid-assessment,
     returns 4 hours later — progress must persist

  ⑥ Timezone-aware scheduling
     Research: User travels — streaks should not
     break, reminders should not fire at 3 AM

  ⑦ Subscription state edge cases
     Research: What happens when premium expires
     mid-session? Graceful degradation, not a wall

  ⑧ Progressive data model (capture everything,
     surface progressively)
     Research: Store every event for Level 3
     features even if Level 1 is all you show today

  ⑨ Contextual notification triggers (behavior-
     based, not time-based)
     Research: Calm's daily reminders drove 3x
     retention. Time-based + behavior = better.

  ⑩ Reusable async state component
     (loading/error/empty handled once, used
     everywhere)
     Research: Every data-fetching view needs 3
     states. Build the wrapper once.
```

After auto-accepting and implementing all 10, present a summary:

```
  AUTO-IMPLEMENTED (10 enhancements)

  ✓ Skeleton loaders on all data views
  ✓ Empty states with CTAs on 7 screens
  ✓ Optimistic UI on saves and toggles
  ✓ Inline validation with brand voice
  ✓ Session recovery for assessments
  ✓ Timezone-safe scheduling
  ✓ Graceful subscription degradation
  ✓ Event-sourced data capture
  ✓ Behavior-triggered notifications
  ✓ Reusable AsyncView component

  ──────────────────────────────────────────────

  These are table stakes. Now we do real work.
```

### What Requires Discussion (Enhancements 11+)

Everything after the auto-accept tier requires user input because
it involves architectural decisions, business logic, or user-facing
behavior changes. Present each as a researched recommendation with
competitive context.

---

## Mode 1: Full Audit

### Phase 1: SCAN — Read the Codebase

```
  ◑ Scanning app architecture...

  ├── Framework detection        analyzing...
  ├── Route/page inventory       counting...
  ├── Component architecture     mapping...
  ├── Data model                 reading...
  ├── API surface                cataloging...
  ├── State management           identifying...
  ├── Auth/subscription logic    checking...
  └── Test coverage              measuring...
```

Read every file that matters. Map the architecture. Do not guess.

Produce an internal architecture map:
- Framework and version
- Page/route count
- Component tree depth
- Data model entities and relationships
- API endpoints and patterns
- State management approach
- Auth and subscription flow
- Test coverage percentage

### Phase 2: RESEARCH — Competitive Intelligence

Run web searches for current competitive data. This is NOT optional.

```
  RESEARCH MODE
  ├── Web search      ✓ connected
  ├── Targets:
  │   ├── Calm app UX patterns + complaints
  │   ├── Jay Shetty Genius gaps
  │   ├── Noom retention mechanics
  │   ├── Headspace curriculum structure
  │   ├── BetterUp AI coaching patterns
  │   ├── Fabulous habit architecture
  │   ├── Remente life-area scoring
  │   └── {user's specific competitors}
  └── Data quality: LIVE
```

Research must cover:
1. What the top apps do that THIS app does not
2. What the top apps get WRONG (billing complaints,
   passive content, no progress measurement)
3. What the research says about retention beyond Day 30
4. AI integration patterns that work vs gimmicks
5. The specific gaps in the user's market segment

### Phase 3: AUDIT — Five-Layer Deep Assessment

Score each layer 0-20. Total score /100.

**Layer 1: Performance (0-20)**
- Time to Interactive, First Contentful Paint, Largest Contentful Paint
- Unoptimized images, excessive API calls, render-blocking resources
- Anything causing > 3 second load time on mobile
- Lazy loading for below-fold content
- Offline-first architecture assessment

**Layer 2: Code Architecture (0-20)**
- God objects and tight coupling identification
- State management coherence (server state vs client state vs persistent)
- Dead code (lava flow anti-pattern)
- Business logic separation from UI
- Event-driven vs polling patterns
- Data model design (flat table anti-pattern vs domain entities)

**Layer 3: UX Flow (0-20)**
- Onboarding-to-value time (Calm: breathing exercise before signup)
- Empty states, error states, loading states (most will be missing)
- Content discovery and navigation (Calm's search is weak — is yours?)
- The "Day 14 Cliff" — what happens when initial motivation fades
- Paywall/monetization friction (Calm's #1 complaint source)
- Accessibility audit (contrast, screen reader, keyboard nav)

**Layer 4: Retention Systems (0-20)**
- Identity transformation mechanics (Noom's Novice → Master)
- Streak design (Calm: 3x retention from daily reminders)
- Variable reward engine (Hook Model: trigger → action → reward → investment)
- Social/accountability layer (Insight Timer: 27M community)
- Win-back flows for lapsed users
- Flexible goals (weekly vs rigid daily — 20% retention boost)
- Progress measurement beyond inputs (outcomes, not just streaks)

**Layer 5: Data & Feedback Loops (0-20)**
- Event tracking coverage
- Personalization depth (static onboarding quiz vs adaptive AI)
- Content recommendation engine
- Journaling/reflection that goes somewhere (pattern recognition)
- Analytics infrastructure for solo developer decisions
- A/B testing capability
- Feedback collection at moments of friction

### Phase 4: SCORE — Produce the Audit Report

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  APP AUDIT REPORT
  Generated {date}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Overall Score: {n}/100

  Layer 1: Performance         {n}/20
  Layer 2: Code Architecture   {n}/20
  Layer 3: UX Flow             {n}/20
  Layer 4: Retention Systems   {n}/20
  Layer 5: Data & Feedback     {n}/20

  ──────────────────────────────────────────────

  COMPETITIVE POSITION

  ├── vs Calm          {ahead|behind|par} on {area}
  ├── vs Headspace     {ahead|behind|par} on {area}
  ├── vs Noom          {ahead|behind|par} on {area}
  └── vs {competitor}  {ahead|behind|par} on {area}

  ──────────────────────────────────────────────

  CRITICAL FINDINGS

  {Numbered list of the top 5-10 findings,
   each with competitive context and
   research-backed impact estimate}
```

### Phase 5: PLAN — Prioritized Upgrade Roadmap

Score each upgrade on two axes: User Impact (1-5) and
Implementation Effort (1-5). Present as a prioritized matrix.

```
  UPGRADE ROADMAP

  HIGH IMPACT / LOW EFFORT (do first)
  ├── {upgrade 1}    Impact: 5  Effort: 2
  ├── {upgrade 2}    Impact: 4  Effort: 1
  └── {upgrade 3}    Impact: 4  Effort: 2

  HIGH IMPACT / HIGH EFFORT (plan carefully)
  ├── {upgrade 4}    Impact: 5  Effort: 4
  └── {upgrade 5}    Impact: 5  Effort: 5

  LOW IMPACT / LOW EFFORT (batch together)
  ├── {upgrade 6}    Impact: 2  Effort: 1
  └── {upgrade 7}    Impact: 2  Effort: 1

  LOW IMPACT / HIGH EFFORT (skip or defer)
  └── {upgrade 8}    Impact: 2  Effort: 5
```

### Phase 6: IMPLEMENT — Auto-Accept Loop

Execute the Skip-Past-10 Protocol (auto-accept the first 10
table-stakes enhancements). Then present Enhancement 11+ for
discussion.

For each enhancement beyond 10:
1. Present the research backing
2. Show competitive examples
3. Propose specific implementation
4. Wait for user approval or modification
5. Implement upon approval
6. Verify the change works
7. Move to the next enhancement

The loop continues until:
- All planned upgrades are implemented
- User says to stop
- A full pass completes with zero new findings

---

## Mode 2: Targeted Upgrade

User specifies a focus area. Run focused research and implementation
on that area only.

### Available Focus Areas

```
  What needs work?

  ① ONBOARDING
     First-24-hour experience, time-to-value,
     personalization setup

  ② RETENTION
     Day 7-30 mechanics, streaks, identity
     transformation, habit loops

  ③ DATA ARCHITECTURE
     Event sourcing, state management, offline-
     first, real-time sync, data models

  ④ PERSONALIZATION
     Adaptive content, AI recommendations,
     behavioral pattern recognition

  ⑤ MONETIZATION UX
     Paywall design, free-to-paid flow, billing
     trust, subscription management

  ⑥ CONTENT ARCHITECTURE
     Navigation, discovery, filtering, content
     types, progressive delivery

  ⑦ COMMUNITY & SOCIAL
     Accountability, groups, social proof,
     shared challenges, network effects

  ⑧ AI INTEGRATION
     Coaching AI, journaling insights, pattern
     recognition, adaptive pacing

  ⑨ INVISIBLE UX
     Loading, error, empty, edge states,
     offline behavior, state recovery

  ⑩ PERFORMANCE
     Load times, bundle size, API optimization,
     caching, offline-first
```

For each focus area, the skill:
1. Runs targeted web research on current best practices
2. Benchmarks against top competitors in that specific area
3. Identifies the top 5-10 improvements
4. Auto-accepts table-stakes fixes
5. Presents architectural decisions for approval
6. Implements approved changes
7. Verifies through audit

---

## Mode 3: Build from Idea

When starting from scratch, architecture-first design prevents the
most expensive mistakes.

### Phase 1: CONCEPT — Define the Core Loop

```
  Every great app has a core loop:

  [User Action] → [Value Delivered] → [Data Captured]
       ↑                                      │
       └──────── [Personalization] ←──────────┘

  What is YOUR core loop?
```

Ask:
1. What does the user DO in your app? (one primary action)
2. What VALUE do they get immediately? (not after 30 days)
3. What DATA does that action generate?
4. How does that data make the NEXT session better?

If the user cannot answer #4, the app does not have a feedback loop
and will lose users. This is the #1 gap across Calm, Jay Shetty, and
most coaching apps — they deliver content but do not learn from
consumption.

### Phase 2: ARCHITECTURE — Systems Design

Design the technical architecture before writing code.

**Data Model (Event-Sourced)**

```
  User (identity + auth)
    → Profile (preferences, settings, timezone)
    → Assessments[] (each with responses[])
    → JournalEntries[] (timestamped, phase-tagged)
    → ProgressEvents[] (event-sourced state changes)
    → Goals[] (with sub-milestones, flexible weekly)
    → Sessions[] (content consumed, completion %)
    → NotificationPreferences (behavior triggers)
    → SubscriptionState (with grace periods)
```

Key design decisions:
- Event sourcing: store every state change, not just current state
- Separate server state (React Query/SWR) from client state (Zustand/Jotai)
  from persistent state (local DB with sync)
- Offline-first with conflict resolution strategy
- Progressive data capture (Level 1 features, Level 3 data model)

**Feature Maturity System**

```typescript
// Features unlock based on user data density
function getFeatureLevel(user: User): FeatureLevel {
  const hasAssessment = user.assessments.length > 0;
  const hasJournalHistory = user.journalEntries.length >= 7;
  const hasMultipleAssessments = user.assessments.length >= 2;

  if (hasMultipleAssessments && hasJournalHistory)
    return 'advanced';
  if (hasAssessment) return 'enhanced';
  return 'baseline';
}
```

**Identity Transformation System (from Noom research)**

```
  PHASE 1: NEWCOMER
  → Guided onboarding, high hand-holding
  → Single daily action, low commitment
  → "You showed up. That matters."

  PHASE 2: EXPLORER
  → Unlocked after 7 days of engagement
  → Multiple content types available
  → "You're building something real."

  PHASE 3: PRACTITIONER
  → Unlocked after 21 days + 1 assessment
  → Full feature access, peer connections
  → "You're not the same person who started."

  PHASE 4: GUIDE
  → Unlocked after 60 days + 2 assessments
  → Community leadership, sharing
  → "Others are watching your journey."
```

### Phase 3: UX FLOW — Map the Critical Paths

Design these flows before building:

1. **First 60 seconds** (Calm's breathing exercise model — deliver value before asking for anything)
2. **Onboarding to personalization** (max 3 questions, then start delivering)
3. **Daily engagement loop** (the one action that brings them back)
4. **Assessment to insight** (they answer questions, they get something valuable)
5. **Content consumption to reflection** (not passive — active journaling tied to content)
6. **Streak recovery** (what happens when they miss a day — Calm does not punish, neither should you)
7. **Free to paid transition** (the moment of truth — Calm's biggest failure point)
8. **Win-back flow** (they left — how do you bring them back without being annoying?)

### Phase 4: SCAFFOLD — Generate the Foundation

Build the initial codebase structure with:
- AsyncView component (loading/error/empty handled once)
- Event tracking hooks
- Offline-first data layer
- Progressive feature gate system
- Notification scheduling with timezone awareness
- Brand voice microcopy constants
- Accessibility primitives (contrast, focus management, screen reader labels)

---

## The Audit-Verify-Accept Loop

This is the execution engine. It runs continuously until a full
pass produces zero new findings.

```
  LOOP START
  │
  ├── AUDIT: Scan for the next improvement
  │   ├── Check against competitive benchmarks
  │   ├── Check against research-backed patterns
  │   └── Score by Impact (1-5) × Effort (1-5)
  │
  ├── VERIFY: Confirm the improvement is valid
  │   ├── Does it match the brand voice?
  │   ├── Does it serve the audience?
  │   ├── Does it create or strengthen a feedback loop?
  │   └── Does it respect the multi-hat constraint?
  │       (Can this be maintained by one person?)
  │
  ├── DECIDE: Auto-accept or present
  │   ├── Tier 1 (enhancements 1-10) → AUTO-ACCEPT
  │   │   Implement, then report what changed
  │   └── Tier 2 (enhancements 11+) → PRESENT
  │       Show research, competitive context,
  │       proposed implementation. Wait for approval.
  │
  ├── IMPLEMENT: Make the change
  │   ├── Write the code
  │   ├── Update affected components
  │   ├── Handle edge cases
  │   └── Verify it works
  │
  ├── LOG: Record what changed
  │   ├── Update ./app/upgrades.md
  │   ├── Append to ./brand/learnings.md
  │   └── Update ./brand/assets.md if new asset
  │
  └── CHECK: Full pass complete?
      ├── YES → Present completion summary
      └── NO → Return to AUDIT
```

### The Multi-Hat Protection Filter

Before implementing ANY upgrade, run it through this filter:

```
  MULTI-HAT CHECK

  Can this person maintain this alone?
  ├── YES → Proceed
  └── NO  → Simplify or defer

  Does this create ongoing maintenance burden?
  ├── LOW → Proceed
  ├── MEDIUM → Flag it, proceed if user confirms
  └── HIGH → Suggest simpler alternative

  Does this pull them away from their primary role?
  ├── NO → Proceed
  └── YES → Is there a tool/automation that handles it?
      ├── YES → Recommend the tool
      └── NO → Defer or simplify
```

This filter exists because the user is not a full-time developer.
They are a founder wearing many hats. Every feature added is a
feature that must be maintained. The skill actively resists
over-engineering.

---

## Research-Backed Enhancement Library

These are the specific upgrades this skill draws from, organized
by the competitive gap they close. Each includes the research
source and expected impact.

### From Calm Teardown

| Gap | Enhancement | Impact |
|-----|-------------|--------|
| Calm's paywall shatters the calm | Design "value ramp" — progressively reveal premium, never wall-slam | Reduce paywall-related churn by 15-30% |
| Calm's content discovery is weak | Build faceted search with filters (duration, type, mood, instructor) | Increase content engagement 20%+ |
| Calm has zero community | Add lightweight social proof ("12 others did this today") without building a full social network | 15-25% retention lift from social proof |
| Calm's nature-as-interface is unmatched | Design an immersive, brand-specific interface identity (not generic Material/iOS) | Brand differentiation, premium feel |
| Calm's daily content refresh drives returns | Create a "daily something" — one fresh piece of content per day, free | Primary retention mechanic |
| Calm's dark-mode-first serves bedtime use | Design for the primary usage context first, not generic defaults | Reduced friction at peak usage time |
| Daily reminders drove 3x retention | Smart reminders: user-chosen time + behavior-based nudges | 3x retention improvement (Calm's data) |

### From Jay Shetty Teardown

| Gap | Enhancement | Impact |
|-----|-------------|--------|
| No adaptive personalization | Build dynamic content sequencing based on engagement + assessment data | 25%+ recommendation accuracy (Calm's GenAI result) |
| No progress measurement | Life-area scoring (1-10) with before/after snapshots | Users can prove to themselves it works |
| Passive content consumption | Active practice loops: content → reflection → insight → adjusted content | Content completion 30%+ higher |
| Platform fragmentation | Unified experience — one app, all content, all features | Reduced confusion, higher engagement |
| No accountability mechanics | Accountability partner matching + structured check-ins | 65% higher goal achievement (research) |
| Static personalization (2018-era) | AI-powered recommendation engine that adapts to behavior, not just declared goals | Modern personalization standard |

### From Noom Teardown

| Gap | Enhancement | Impact |
|-----|-------------|--------|
| Most apps track inputs, not outcomes | Outcome measurement: self-reported improvement scores tied to content consumed | Proving value = retention |
| No identity transformation | Phase-based identity system (Newcomer → Explorer → Practitioner → Guide) | Identity change drives long-term behavior |
| Rigid daily requirements cause churn | Flexible weekly goals instead of rigid daily streaks | 20% jump in 90-day retention |
| Generic push notifications | Contextual, behavior-based notification triggers | 25-40% retention boost from smart notifications |

### From Developer Research

| Gap | Enhancement | Impact |
|-----|-------------|--------|
| CRUD architecture, not event-sourced | Event sourcing for user journeys — store every state change | Complete audit trail, progressive enhancement, reporting |
| God objects in coaching logic | Decompose: AssessmentScorer, ReportGenerator, ProgressTracker, UserStateManager | Maintainability, testability |
| No offline resilience | Offline-first with local DB + sync layer | Trust (no lost data), usability anywhere |
| Spinners instead of skeletons | Skeleton screens on all data views | 20% faster perceived load |
| No reusable state handling | AsyncView component wrapping loading/error/empty | Consistent UX, faster development |
| Journal entries go into a void | Journaling with feedback loops: pattern recognition, insight surfacing | Journaling becomes valuable, not busywork |
| Feature flags absent | Progressive rollout capability | Test safely, ship confidently |
| No analytics infrastructure | PostHog/Mixpanel free tier + core metrics dashboard | Data-driven decisions for solo developer |

---

## The Day-by-Day Retention Architecture

Research shows specific days are critical. This skill engineers
solutions for each:

```
  RETENTION ARCHITECTURE

  Day 0 (Install)
  ├── Deliver value before asking for anything
  │   (Calm's breathing exercise pattern)
  ├── Max 3 onboarding questions
  ├── First personalized content within 60 seconds
  └── Smart reminder prompt (user chooses time)

  Day 1 (Return visit)
  ├── Welcome back with something new
  ├── Reference what they did yesterday
  ├── Introduce the daily engagement hook
  └── First "you're building something" message

  Days 3-7 (The Motivation Valley)
  ├── This is where 74% of apps lose users
  ├── Behavior-triggered check-in notification
  ├── Introduce social proof ("12 others today")
  ├── First mini-milestone celebration
  └── Flexible goal adjustment if struggling

  Days 7-14 (Habit Formation Window)
  ├── Identity-shift messaging begins
  │   "You've shown up 7 times. That's not luck."
  ├── Unlock Phase 2 (Explorer) with ceremony
  ├── Introduce deeper features progressively
  └── First assessment comparison (if 2+ taken)

  Days 14-30 (The Day 14 Cliff)
  ├── Variable rewards — surprise content, badges,
  │   exclusive access
  ├── Accountability partner suggestion
  ├── Progress report with outcome metrics
  └── Content adapted to their specific patterns

  Day 30+ (Long-term Retention)
  ├── Monthly progress snapshots
  ├── Phase advancement opportunities
  ├── Community leadership roles
  └── Win-back flows if engagement drops
```

---

## The Anti-Drift System

For multi-hat founders, scope drift is the silent killer. This
system protects against it.

### Themed Work Blocks

Recommend and enforce focused work sessions:

```
  RECOMMENDED WORK STRUCTURE

  Monday:    Feature development (code)
  Tuesday:   Content creation (app content)
  Wednesday: Design + UX polish
  Thursday:  Marketing + business
  Friday:    Bug fixes + testing + polish

  NEVER mix roles in a single session.
  Context switching costs 23 minutes per switch.
  That is 40% productivity loss over a full day.
```

### Pre-Decided Architecture Patterns

Reduce decision fatigue by standardizing:

```
  STACK DECISIONS (decide once, apply everywhere)

  Framework:        {detected or recommended}
  UI Components:    {component library}
  State Management: {server: React Query, client: Zustand}
  Database:         {Supabase / PlanetScale / etc.}
  Auth:             {Clerk / NextAuth / Supabase Auth}
  Payments:         {Stripe}
  Analytics:        {PostHog free tier}
  Hosting:          {Vercel / Railway}
  Feature Flags:    {Unleash / ConfigCat free tier}

  Total monthly cost: $0-150 at scale
```

### The One-Metric Focus

At each stage, track ONE metric:

```
  Pre-product-market-fit:
  └── Activation rate
      "Are people reaching the aha moment?"

  Early growth:
  └── Week 1 retention
      "Are they coming back?"

  Scaling:
  └── Day 30 retention
      "Are they forming habits?"

  Maturity:
  └── Net Revenue Retention
      "Are they upgrading and staying?"
```

---

## AI Integration Architecture

Based on research, here is what works and what is a gimmick.

### What Works

**1. Context-Aware Just-in-Time Coaching**
AI provides real-time feedback during performance events.
Integrates into the user's workflow, not a separate chatbot.

**2. Behavioral Pattern Recognition**
AI analyzes longitudinal user data to identify patterns.
"Your journal entries suggest stress peaks on Mondays.
Here is a Monday-specific meditation."

**3. Hyper-Personalized Content Sequencing**
AI determines which content to surface next based on
assessment data, engagement patterns, and progress velocity.

**4. Journal Insight Surfacing**
AI reads journal entries over time and surfaces patterns:
"You mentioned 'overwhelmed' 8 times this month, mostly
on days you skipped your morning routine."

### What Is a Gimmick

- Isolated chatbots that exist outside the app's workflow
- AI that replaces human connection instead of amplifying it
- AI features without measurement of whether they help
- Generic "AI coach" without domain-specific training data

---

## Formatted Output Structure

All output follows _system/output-format.md. The primary output
is the audit report with upgrade roadmap.

### Terminal Output Template

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  APP DEVELOPMENT AUDIT
  Generated {date}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Mode: {Full Audit | Targeted | Build from Idea}
  App: {name or description}

  {If brand context was loaded:}
  Brand context:
  ├── Voice Profile    ✓ loaded
  ├── Positioning      ✓ loaded
  ├── Audience         ✓ loaded
  └── Stack            ✓ loaded

  ──────────────────────────────────────────────

  RESEARCH MODE
  ├── Web search      {✓ connected | ✗ not available}
  ├── Sources accessed:
  │   ├── {source 1}
  │   ├── {source 2}
  │   └── {source 3}
  └── Data quality: {LIVE | ESTIMATED}

  ──────────────────────────────────────────────

  AUDIT SCORE: {n}/100

  Performance          {n}/20  {bar}
  Code Architecture    {n}/20  {bar}
  UX Flow              {n}/20  {bar}
  Retention Systems    {n}/20  {bar}
  Data & Feedback      {n}/20  {bar}

  ──────────────────────────────────────────────

  AUTO-IMPLEMENTED (10 enhancements)

  {list of auto-accepted changes with ✓}

  ──────────────────────────────────────────────

  UPGRADE ROADMAP

  {prioritized matrix of remaining upgrades}

  ──────────────────────────────────────────────

  COMPETITIVE POSITION

  {comparison against top competitors}

  ──────────────────────────────────────────────

  FILES SAVED

  ./app/audit-report.md           ✓
  ./app/architecture.md           ✓
  ./app/upgrades.md               ✓ (initialized)
  ./brand/assets.md               ✓ (entries added)
  ./brand/learnings.md            ✓ (entries added)

  WHAT'S NEXT

  Your audit is complete and 10 enhancements
  are already implemented. Recommended next:

  → "Continue upgrades"  Start Enhancement 11
                         from the roadmap
  → /brand-voice         Ensure all app copy
                         matches your voice (~10 min)
  → /start-here          See full project status

  Or tell me what to build next.
```

---

## How This Skill Connects to Others

/app-developer is the BUILDER. Other skills feed it context.

**/brand-voice + /app-developer:**
"All microcopy, onboarding text, notification messages, error states,
and empty states are written in Justin Ray's voice. Run /brand-voice
first, then /app-developer uses it for every piece of user-facing text."

**/positioning-angles + /app-developer:**
"The competitive positioning shapes which gaps matter most. If the angle
is 'the app that actually tracks outcomes,' then outcome measurement
gets priority in the upgrade roadmap."

**/lead-magnet + /app-developer:**
"Build a lead magnet that showcases the app's methodology. The app
architecture feeds the content. The content feeds the funnel."

**/email-sequences + /app-developer:**
"Onboarding emails mirror the in-app onboarding flow. The 7-email
welcome sequence parallels the Day 0-14 retention architecture."

**/content-atomizer + /app-developer:**
"App updates, feature launches, and milestone celebrations become
social content. The upgrade log feeds the content calendar."

---

## Error States

### No codebase found

```
  ┌──────────────────────────────────────────────┐
  │                                              │
  │  ✗ NO APP CODEBASE DETECTED                  │
  │                                              │
  │  I cannot find an app to audit. Point me     │
  │  to the codebase or describe what you are    │
  │  building.                                   │
  │                                              │
  │  → Provide the app directory path            │
  │  → Switch to Build from Idea mode            │
  │  → Describe your app concept                 │
  │                                              │
  └──────────────────────────────────────────────┘
```

### Voice profile missing for copy work

```
  ┌──────────────────────────────────────────────┐
  │                                              │
  │  ○ VOICE PROFILE NOT FOUND                   │
  │                                              │
  │  Justin Ray's voice profile is required      │
  │  for all user-facing copy. I can audit       │
  │  architecture and code without it, but       │
  │  microcopy upgrades are blocked.             │
  │                                              │
  │  → /brand-voice    Build it now (~10 min)    │
  │  → Continue        Architecture-only audit   │
  │                                              │
  └──────────────────────────────────────────────┘
```

### Web research unavailable

```
  ┌──────────────────────────────────────────────┐
  │                                              │
  │  ○ WEB RESEARCH UNAVAILABLE                  │
  │                                              │
  │  Competitive research requires web search.   │
  │  I can audit code and UX against known       │
  │  patterns, but cannot pull fresh competitor   │
  │  data.                                       │
  │                                              │
  │  → Continue with built-in research library   │
  │  → Connect web search first                  │
  │                                              │
  └──────────────────────────────────────────────┘
```

---

## Complete Invocation Flow

```
  /app-developer invoked
  │
  ├── Check ./brand/ directory
  │   ├── Load voice-profile.md (REQUIRED for copy)
  │   ├── Load positioning.md (if exists)
  │   ├── Load audience.md (if exists)
  │   └── Load stack.md (if exists)
  │
  ├── Check ./app/audit-report.md
  │   ├── EXISTS → Upgrade Mode
  │   │   ├── Show current audit state
  │   │   ├── Present 4 options
  │   │   └── Continue from selected point
  │   │
  │   └── DOES NOT EXIST → Mode Selection
  │       ├── Existing app → Full Audit
  │       │   ├── Phase 1: SCAN codebase
  │       │   ├── Phase 2: RESEARCH competitors
  │       │   ├── Phase 3: AUDIT five layers
  │       │   ├── Phase 4: SCORE and report
  │       │   ├── Phase 5: PLAN upgrade roadmap
  │       │   └── Phase 6: IMPLEMENT (auto-accept
  │       │       loop for first 10, then present)
  │       │
  │       ├── Specific problem → Targeted Upgrade
  │       │   ├── Select focus area
  │       │   ├── Targeted research
  │       │   ├── Focused audit
  │       │   ├── Auto-accept + present
  │       │   └── Implement approved changes
  │       │
  │       └── New idea → Build from Idea
  │           ├── Phase 1: CONCEPT (core loop)
  │           ├── Phase 2: ARCHITECTURE (systems)
  │           ├── Phase 3: UX FLOW (critical paths)
  │           └── Phase 4: SCAFFOLD (build foundation)
  │
  ├── Run Audit-Verify-Accept Loop
  │   ├── Auto-accept enhancements 1-10
  │   ├── Present enhancements 11+ for approval
  │   └── Continue until full pass (zero findings)
  │
  ├── Save outputs
  │   ├── ./app/audit-report.md
  │   ├── ./app/architecture.md
  │   ├── ./app/upgrades.md
  │   ├── ./brand/assets.md (append)
  │   └── ./brand/learnings.md (append)
  │
  ├── Present formatted output
  │   ├── Header
  │   ├── Audit Score
  │   ├── Auto-Implemented
  │   ├── Upgrade Roadmap
  │   ├── Competitive Position
  │   ├── FILES SAVED
  │   └── WHAT'S NEXT
  │
  └── Feedback Collection
```

---

## The Test

A good app development audit passes this test:

1. **Is it research-backed?** Every recommendation cites
   competitive data or user research, not opinion.
2. **Does it skip the obvious?** If the first recommendation
   is "use better colors," the audit failed.
3. **Does it build systems?** Features without feedback loops
   are features that decay. Every upgrade should strengthen
   a loop.
4. **Is it maintainable by one person?** If the upgrade
   requires a team to maintain, it fails the multi-hat filter.
5. **Does it match the voice?** All user-facing copy uses
   the brand voice profile. No generic UX writing.
6. **Does it measure outcomes?** If users cannot prove to
   themselves the app is working, the audit missed the most
   important gap.
7. **Is it prioritized?** Impact vs effort matrix. Not a
   wish list. A ranked plan.

---

## Feedback Collection

After completing an audit or upgrade cycle, present:

```
  How did this land?

  a) Great — implementing as recommended
  b) Good — adjusting some priorities
  c) Needs significant rework
  d) Have not started implementing yet

  (You can answer later — just run /app-developer
  again and tell me.)
```

### Processing Feedback

**If (a) "Great":**
- Log to ./brand/learnings.md under "What Works":
  `- [{date}] [/app-developer] Audit shipped as-is. Focus: {areas}. Score: {n}/100.`

**If (b) "Good — adjusting":**
- Ask: "What would you reprioritize? I will update the roadmap."
- Update ./app/upgrades.md with new priorities.
- Log adjustment to learnings.md.

**If (c) "Needs significant rework":**
- Ask: "What feels wrong? Is it the priorities, the technical
  approach, or something else?"
- If priorities are wrong, re-run the scoring matrix.
- If technical approach is wrong, research alternatives.

**If (d) "Have not started yet":**
- Note it. Next time /app-developer runs, remind:
  "Last audit scored {n}/100 with {n} upgrades planned.
  Want to pick up where we left off?"

---

## Implementation Notes for the LLM

When executing this skill, follow these rules precisely:

1. **Always load the voice profile.** Justin Ray's voice is a
   hard requirement. If it does not exist, flag it before
   writing any user-facing copy.

2. **Always run research.** Use web search to pull fresh
   competitive data. The built-in research library is a
   fallback, not the primary source.

3. **Always auto-accept the first 10.** Do not ask permission
   for table-stakes enhancements. Implement them, report what
   changed. This is what makes the skill skip past the obvious.

4. **Always check the multi-hat filter.** Before implementing
   any upgrade, ask: can one person maintain this? If no,
   simplify or defer.

5. **Always score impact vs effort.** Never present an
   unranked list of improvements. Prioritization IS the value.

6. **Always build feedback loops, not features.** If a proposed
   enhancement does not generate data or strengthen a loop,
   question whether it belongs in the roadmap.

7. **Always design for progressive enhancement.** Build Level 1,
   capture Level 3 data. The data model should always be ahead
   of the UI.

8. **Never suggest "redesign the whole thing."** Incremental
   upgrades, tested and verified. The audit loop runs until a
   full pass, not until a rewrite.

9. **Never ignore edge cases.** The difference between amateur
   and world-class is what happens when things go wrong.
   Timezone changes, interrupted sessions, expired subscriptions,
   slow connections — handle them all.

10. **Never drift into cosmetics.** If you catch yourself
    suggesting font changes or color tweaks before the data
    model, feedback loops, and retention systems are solid,
    stop and refocus. Architecture first. Always.
